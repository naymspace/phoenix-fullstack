stages:
  - pre-analyze
  - analyze
  - post-analyze
  - test
  - build
  - deploy

# ########
# Build a docker image to analyze the code
# ########
build-analyze:
  stage: pre-analyze
  image: docker:git
  script:
    - docker login -u gitlab-ci-token -p $CI_JOB_TOKEN $CI_REGISTRY
    - docker build -t $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_SLUG-analyze -f Dockerfile_analyze .
    - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_SLUG-analyze

# ########
# Removes the docker image after analyze
# ########
remove-analyze:
  stage: post-analyze
  image: docker:git
  # Execute the remove analyze job even if the previous stage faild
  when: always
  script:
    - docker login -u gitlab-ci-token -p $CI_JOB_TOKEN $CI_REGISTRY
    - docker rmi --force $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_SLUG-analyze

# ########
# Frontend - Check for vulnerabilities
# ########
npm-audit:
  image: $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_SLUG-analyze
  stage: analyze
  retry: 2 # Retry this job because sometimes the NPM registry fails to answer
  script:
    - npm audit --prefix assets

# ########
# Backend - Check format
# ########
format:
  image: $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_SLUG-analyze
  stage: analyze
  script:
    - mix format --check-formatted

# ######
# Backend tests
# ######
.tests:
  stage: test
  image: elixir:1.10.2-alpine
  services:
    - name: postgres:11-alpine
      alias: postgres
  variables:
    POSTGRES_DATABASE: db_test
    POSTGRES_HOST: postgres
    POSTGRES_USER: phoenix
    POSTGRES_PASSWORD: phoenix
    DATABASE_URL: postgres://phoenix:phoenix@postgres:5432/db_test
    MIX_ENV: "test"
  coverage: '/\d+.\d+\%\s+\|\s+Total/'
  artifacts:
    reports:
      junit: _build/test/lib/ted/test-junit-report.xml
  before_script:
    - mix local.rebar --force
    - mix local.hex --force
    - mix deps.get --only test
    - mix ecto.create
    - mix ecto.migrate
  script:
    - mix test-quiet --coverage

# ######
# Build dev
# ######
build-dev:
  stage: build
  image: docker:git
  except:
    - master
  script:
    - docker login -u gitlab-ci-token -p $CI_JOB_TOKEN $CI_REGISTRY
    - docker build -t $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_SLUG .
    - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_SLUG

# ######
# Build production
# ######
build-prod:
  stage: build
  image: docker:git
  only:
    - master
  script:
    - docker login -u gitlab-ci-token -p $CI_JOB_TOKEN $CI_REGISTRY
    - docker build -t $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_SLUG -f Dockerfile_prod .
    - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_SLUG

# ######
# Deployment template
# ######
.deploy: &deploy
  stage: deploy
  image: docker:git
  variables:
    GIT_STRATEGY: none
  before_script:
    - echo TODO IMPLEMENT

# ######
# Deployment for feature environment (any non dev or master branch)
# ######
deploy feature:
  <<: *deploy
  environment:
    name: feature
    url: https://feature.domain
  when: manual
  except:
    - develop
    - master
  script:
    - echo TODO IMPLEMENT

# ######
# Deployment for the development / staging stage
# ######
deploy develop:
  <<: *deploy
  environment:
    name: develop
    url: https://develop.domain
  when: manual
  only:
    - develop
  script:
    - echo TODO IMPLEMENT

# ######
# Deployment for production / live environment
# ######
deploy production:
  <<: *deploy
  environment:
    name: production
    url: https://production.domain
  when: manual
  only:
    - master
  script:
    - echo TODO IMPLEMENT
